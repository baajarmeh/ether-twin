"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.extractTarStreamTo = exports.writeStreamTo = exports.isFile = void 0;

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _fsExtra = require("fs-extra");

var _tarStream = _interopRequireDefault(require("tar-stream"));

const isFile = async path => {
  const stat = await (0, _fsExtra.lstat)(path);
  return stat.isFile();
};

exports.isFile = isFile;

const writeStreamTo = async (stream, filePath) => {
  await (0, _fsExtra.ensureDir)(_path.default.dirname(filePath));
  await new Promise((resolve, reject) => {
    stream.pipe((0, _fs.createWriteStream)(filePath)).on('error', err => {
      reject(err);
    }).on('finish', () => {
      resolve();
    });
  });
};

exports.writeStreamTo = writeStreamTo;

const extractTarStreamTo = async (stream, dirPath) => {
  await (0, _fsExtra.ensureDir)(dirPath);
  return await new Promise((resolve, reject) => {
    const extract = _tarStream.default.extract();

    const writeFiles = []; // Keep track of files to write

    extract.on('entry', (header, stream, next) => {
      if (header.type === 'file' && header.name.length > 0) {
        const filePath = _path.default.join(dirPath, header.name);

        const fileWritten = writeStreamTo(stream, filePath).then(() => {
          next(); // Extract next entry after file has been written
        });
        writeFiles.push(fileWritten);
      } else {
        next();
      }
    });
    extract.on('error', err => {
      reject(err);
    });
    extract.on('finish', async () => {
      // Wait until all files have been written before resolving
      try {
        await Promise.all(writeFiles);
        resolve(writeFiles.length);
      } catch (err) {
        reject(err);
      }
    });
    stream.pipe(extract);
  });
};

exports.extractTarStreamTo = extractTarStreamTo;