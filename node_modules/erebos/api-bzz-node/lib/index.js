"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _fs = require("fs");

var _apiBzzBase = _interopRequireDefault(require("@erebos/api-bzz-base"));

var _formData = _interopRequireDefault(require("form-data"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _rxjs = require("rxjs");

var _tarFs = _interopRequireDefault(require("tar-fs"));

var _tarStream = _interopRequireDefault(require("tar-stream"));

var _fs2 = require("./fs");

class Bzz extends _apiBzzBase.default {
  constructor(config) {
    const {
      url
    } = config,
          cfg = (0, _objectWithoutPropertiesLoose2.default)(config, ["url"]);
    super((0, _extends2.default)({}, cfg, {
      url: new URL(url).href
    }));
    this._fetch = _nodeFetch.default;
  }

  async _downloadTar(hash, options) {
    if (options.headers == null) {
      options.headers = {};
    }

    options.headers.accept = 'application/x-tar';
    return await this._download(hash, options);
  }

  downloadObservable(hash, options = {}) {
    return _rxjs.Observable.create(observer => {
      this._downloadTar(hash, options).then(res => {
        const extract = _tarStream.default.extract();

        extract.on('entry', (header, stream, next) => {
          if (header.type === 'file') {
            const chunks = [];
            stream.on('data', chunk => {
              chunks.push(chunk);
            });
            stream.on('end', () => {
              observer.next({
                data: Buffer.concat(chunks),
                path: header.name,
                size: header.size
              });
              next();
            });
            stream.resume();
          } else {
            next();
          }
        });
        extract.on('finish', () => {
          observer.complete();
        });
        res.body.pipe(extract);
      }, err => {
        observer.error(err);
      });
    });
  }

  downloadDirectoryData(hash, options = {}) {
    return new Promise((resolve, reject) => {
      const directoryData = {};
      this.downloadObservable(hash, options).subscribe({
        next: entry => {
          directoryData[entry.path] = {
            data: entry.data,
            size: entry.size
          };
        },
        error: err => {
          reject(err);
        },
        complete: () => {
          resolve(directoryData);
        }
      });
    });
  }

  async downloadFileTo(hash, toPath, options = {}) {
    const res = await this._download(hash, options);
    await (0, _fs2.writeStreamTo)(res.body, toPath);
  }

  async downloadDirectoryTo(hash, toPath, options = {}) {
    const res = await this._downloadTar(hash, options);
    return await (0, _fs2.extractTarStreamTo)(res.body, toPath);
  }

  async downloadTo(hash, toPath, options = {}) {
    if (await (0, _fs2.isFile)(toPath)) {
      await this.downloadFileTo(hash, toPath, options);
    } else {
      await this.downloadDirectoryTo(hash, toPath, options);
    }
  }

  async uploadDirectory(directory, options = {}) {
    const form = new _formData.default();
    Object.keys(directory).forEach(key => {
      form.append(key, directory[key].data, {
        contentType: directory[key].contentType
      });
    });

    if (options.defaultPath != null) {
      const file = directory[options.defaultPath];

      if (file != null) {
        form.append('', file.data, {
          contentType: file.contentType
        });
      }
    }

    const headers = options.headers || {};
    options.headers = (0, _extends2.default)({}, headers, form.getHeaders());
    return await this._upload(form, options);
  }

  async uploadFileStream(stream, options = {}) {
    const raw = options.contentType == null;

    if (!raw) {
      if (options.headers == null) {
        options.headers = {};
      }

      options.headers['content-type'] = options.contentType;
    }

    return await this._upload(stream, options, raw);
  }

  async uploadFileFrom(path, options) {
    return await this.uploadFileStream((0, _fs.createReadStream)(path), options);
  }

  async _uploadTarStream(stream, options = {}) {
    if (options.headers == null) {
      options.headers = {};
    }

    options.headers['content-type'] = 'application/x-tar';
    return await this._upload(stream, options);
  } // path must be either a tar archive or a directory


  async uploadTar(path, options = {}) {
    const stream = (await (0, _fs2.isFile)(path)) ? (0, _fs.createReadStream)(path) : _tarFs.default.pack(path);
    return await this._uploadTarStream(stream, options);
  }

  async uploadDirectoryFrom(path, options = {}) {
    return await this._uploadTarStream(_tarFs.default.pack(path), options);
  }

  async uploadFrom(path, options = {}) {
    if (await (0, _fs2.isFile)(path)) {
      return await this.uploadFileFrom(path, options);
    } else {
      return await this.uploadDirectoryFrom(path, options);
    }
  }

}

exports.default = Bzz;