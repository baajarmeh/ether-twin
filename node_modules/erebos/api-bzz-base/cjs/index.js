"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
var _exportNames = {
  BZZ_MODE_PROTOCOLS: true,
  getModeProtocol: true,
  HTTPError: true,
  resOrError: true,
  resJSON: true,
  resText: true,
  resSwarmHash: true
};
exports.default = exports.resSwarmHash = exports.resText = exports.resJSON = exports.resOrError = exports.HTTPError = exports.getModeProtocol = exports.BZZ_MODE_PROTOCOLS = void 0;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _hex = _interopRequireWildcard(require("@erebos/hex"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _feed = require("./feed");

Object.keys(_feed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _feed[key];
});

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _types[key];
});
var BZZ_MODE_PROTOCOLS = {
  default: 'bzz:/',
  feed: 'bzz-feed:/',
  immutable: 'bzz-immutable:/',
  raw: 'bzz-raw:/'
};
exports.BZZ_MODE_PROTOCOLS = BZZ_MODE_PROTOCOLS;

var getModeProtocol = function getModeProtocol(mode) {
  return mode && BZZ_MODE_PROTOCOLS[mode] || BZZ_MODE_PROTOCOLS.default;
};

exports.getModeProtocol = getModeProtocol;

var HTTPError =
/*#__PURE__*/
function (_Error) {
  (0, _inheritsLoose2.default)(HTTPError, _Error);

  function HTTPError(status, message) {
    var _this;

    _this = _Error.call(this, message) || this;
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "status", void 0);
    _this.status = status;
    return _this;
  }

  return HTTPError;
}((0, _wrapNativeSuper2.default)(Error));

exports.HTTPError = HTTPError;

var resOrError = function resOrError(res) {
  return res.ok ? Promise.resolve(res) : Promise.reject(new HTTPError(res.status, res.statusText));
};

exports.resOrError = resOrError;

var resJSON = function resJSON(res) {
  return resOrError(res).then(function (r) {
    return r.json();
  });
};

exports.resJSON = resJSON;

var resText = function resText(res) {
  return resOrError(res).then(function (r) {
    return r.text();
  });
};

exports.resText = resText;

var resSwarmHash = function resSwarmHash(res) {
  return resOrError(res).then(function (r) {
    return r.arrayBuffer();
  }).then(function (value) {
    return Buffer.from(new Uint8Array(value)).toString('hex');
  });
};

exports.resSwarmHash = resSwarmHash;

var defaultSignBytes = function defaultSignBytes() {
  return Promise.reject(new Error('Missing `signBytes()` function'));
};

var BaseBzz =
/*#__PURE__*/
function () {
  function BaseBzz(config) {
    (0, _defineProperty2.default)(this, "_defaultTimeout", void 0);
    (0, _defineProperty2.default)(this, "_fetch", void 0);
    (0, _defineProperty2.default)(this, "_signBytes", void 0);
    (0, _defineProperty2.default)(this, "_url", void 0);
    var url = config.url,
        timeout = config.timeout;
    this._defaultTimeout = timeout ? timeout : 0;
    this._signBytes = config.signBytes || defaultSignBytes;
    this._url = url;
  }

  var _proto = BaseBzz.prototype;

  _proto._fetchTimeout = function _fetchTimeout(url, options, params) {
    var _this2 = this;

    if (params === void 0) {
      params = {};
    }

    var timeout = options.timeout == null ? this._defaultTimeout : options.timeout;

    if (options.headers != null) {
      params.headers = options.headers;
    }

    if (timeout === 0) {
      // No timeout
      return this._fetch(url, params);
    }

    return new Promise(function (resolve, reject) {
      var timeoutID = setTimeout(function () {
        reject(new Error('Timeout'));
      }, timeout);

      _this2._fetch(url, params).then(function (res) {
        clearTimeout(timeoutID);
        resolve(res);
      });
    });
  };

  _proto.sign = function sign(bytes, params) {
    return this._signBytes(bytes, params).then(_feed.bytesToHexValue);
  };

  _proto.getDownloadURL = function getDownloadURL(hash, options, raw) {
    if (options === void 0) {
      options = {};
    }

    if (raw === void 0) {
      raw = false;
    }

    var protocol = raw ? BZZ_MODE_PROTOCOLS.raw : getModeProtocol(options.mode);
    var url = "" + this._url + protocol + hash + "/";

    if (options.path != null) {
      url += options.path;
    }

    if (options.mode === 'raw' && options.contentType != null) {
      url += "?content_type=" + options.contentType;
    }

    return url;
  };

  _proto.getUploadURL = function getUploadURL(options, raw) {
    if (options === void 0) {
      options = {};
    }

    if (raw === void 0) {
      raw = false;
    }

    // Default URL to creation
    var url = this._url + BZZ_MODE_PROTOCOLS[raw ? 'raw' : 'default']; // Manifest update if hash is provided

    if (options.manifestHash != null) {
      url += options.manifestHash + "/";

      if (options.path != null) {
        url += options.path;
      }
    }

    if (options.defaultPath != null) {
      url += "?defaultpath=" + options.defaultPath;
    }

    return url;
  };

  _proto.getFeedURL = function getFeedURL(hashOrParams, flag) {
    var url = this._url + BZZ_MODE_PROTOCOLS.feed;
    var query = [];

    if (typeof hashOrParams === 'string') {
      // feed hash
      url += hashOrParams + "/";
    } else {
      // feed params
      query = Object.keys(hashOrParams).reduce(function (acc, key) {
        // $FlowFixMe: hashOrParams type
        var value = hashOrParams[key];

        if (value != null) {
          acc.push(key + "=" + value);
        }

        return acc;
      }, []);
    }

    if (flag != null) {
      query.push(flag + "=1");
    }

    return query.length > 0 ? url + "?" + query.join('&') : url;
  };

  _proto.hash = function hash(domain, options) {
    if (options === void 0) {
      options = {};
    }

    return this._fetchTimeout(this._url + "bzz-hash:/" + domain, options).then(resText);
  };

  _proto.list = function list(hash, options) {
    if (options === void 0) {
      options = {};
    }

    var url = this._url + "bzz-list:/" + hash + "/";

    if (options.path != null) {
      url += options.path;
    }

    return this._fetchTimeout(url, options).then(resJSON);
  };

  _proto._download = function _download(hash, options) {
    var url = this.getDownloadURL(hash, options);
    return this._fetchTimeout(url, options).then(resOrError);
  };

  _proto.download = function download(hash, options) {
    if (options === void 0) {
      options = {};
    }

    return this._download(hash, options);
  };

  _proto._upload = function _upload(body, options, raw) {
    if (raw === void 0) {
      raw = false;
    }

    var url = this.getUploadURL(options, raw);
    return this._fetchTimeout(url, options, {
      body: body,
      method: 'POST'
    }).then(resText).then(_hex.hexValueType);
  };

  _proto.uploadFile = function uploadFile(data, options) {
    if (options === void 0) {
      options = {};
    }

    var body = typeof data === 'string' ? Buffer.from(data) : data;
    var raw = options.contentType == null;

    if (options.headers == null) {
      options.headers = {};
    }

    options.headers['content-length'] = body.length;

    if (options.headers != null && options.headers['content-type'] == null && !raw) {
      options.headers['content-type'] = options.contentType;
    }

    return this._upload(body, options, raw);
  };

  _proto.uploadDirectory = function uploadDirectory(_directory, _options) {
    return Promise.reject(new Error('Must be implemented in extending class'));
  };

  _proto.upload = function upload(data, options) {
    if (options === void 0) {
      options = {};
    }

    return typeof data === 'string' || Buffer.isBuffer(data) ? // $FlowFixMe: Flow doesn't understand type refinement with Buffer check
    this.uploadFile(data, options) : this.uploadDirectory(data, options);
  };

  _proto.deleteResource = function deleteResource(hash, path, options) {
    if (options === void 0) {
      options = {};
    }

    var url = this.getUploadURL({
      manifestHash: hash,
      path: path
    });
    return this._fetchTimeout(url, options, {
      method: 'DELETE'
    }).then(resText);
  };

  _proto.createFeedManifest = function createFeedManifest(params, options) {
    if (options === void 0) {
      options = {};
    }

    var manifest = {
      entries: [{
        contentType: 'application/bzz-feed',
        mod_time: '0001-01-01T00:00:00Z',
        feed: {
          topic: (0, _feed.getFeedTopic)(params),
          user: params.user
        }
      }]
    };
    return this.uploadFile(JSON.stringify(manifest), options).then(_hex.hexValueType);
  };

  _proto.getFeedMetadata = function getFeedMetadata(hashOrParams, options) {
    if (options === void 0) {
      options = {};
    }

    var url = this.getFeedURL(hashOrParams, 'meta');
    return this._fetchTimeout(url, options).then(resJSON);
  };

  _proto.getFeedChunk = function getFeedChunk(hashOrParams, options) {
    if (options === void 0) {
      options = {};
    }

    var url = this.getFeedURL(hashOrParams);
    return this._fetchTimeout(url, options).then(resOrError);
  };

  _proto.getFeedContentHash = function getFeedContentHash(hashOrParams, options) {
    if (options === void 0) {
      options = {};
    }

    return this.getFeedChunk(hashOrParams, options).then(resSwarmHash);
  };

  _proto.getFeedContent = function getFeedContent(hashOrParams, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    return this.getFeedContentHash(hashOrParams, {
      headers: options.headers,
      timeout: options.timeout
    }).then(function (hash) {
      return _this3.download(hash, options);
    });
  };

  _proto.pollFeedChunk = function pollFeedChunk(hashOrParams, options) {
    var _this4 = this,
        _merge;

    var sources = []; // Trigger the flow immediately by default

    if (options.immediate !== false) {
      sources.push([0]);
    } // An external trigger can be provided in the options so the consumer can execute the flow when needed


    if (options.trigger != null) {
      sources.push(options.trigger);
    }

    var pipeline = []; // Handle whether the subscription should fail if the feed doesn't have a value

    if (options.whenEmpty === 'error') {
      pipeline.push((0, _operators.flatMap)(function () {
        return _this4.getFeedChunk(hashOrParams, options);
      }));
    } else {
      var url = this.getFeedURL(hashOrParams);
      pipeline.push((0, _operators.flatMap)(function () {
        return _this4._fetchTimeout(url, options).then(function (res) {
          if (res.status === 404) {
            return null;
          }

          if (res.ok) {
            return res;
          }

          return new HTTPError(res.status, res.statusText);
        });
      })); // Default behavior will emit null values, only omit them when option is set

      if (options.whenEmpty === 'ignore') {
        pipeline.push((0, _operators.filter)(function (res) {
          return res !== null;
        }));
      }
    }

    return (_merge = _rxjs.merge.apply(void 0, [(0, _rxjs.interval)(options.interval)].concat(sources))).pipe.apply(_merge, pipeline);
  };

  _proto.pollFeedContentHash = function pollFeedContentHash(hashOrParams, options) {
    var _this$pollFeedChunk;

    var pipeline = [(0, _operators.flatMap)(function (res) {
      return res === null ? Promise.resolve(null) : resSwarmHash(res);
    })];

    if (options.changedOnly) {
      pipeline.push((0, _operators.distinctUntilChanged)());
    }

    return (_this$pollFeedChunk = this.pollFeedChunk(hashOrParams, options)).pipe.apply(_this$pollFeedChunk, pipeline);
  };

  _proto.pollFeedContent = function pollFeedContent(hashOrParams, options) {
    var _this5 = this;

    return this.pollFeedContentHash(hashOrParams, options).pipe((0, _operators.flatMap)(function (hash) {
      return hash === null ? Promise.resolve(null) : _this5.download(hash, options);
    }));
  };

  _proto.postSignedFeedChunk = function postSignedFeedChunk(params, body, options) {
    if (options === void 0) {
      options = {};
    }

    var url = this.getFeedURL(params);
    return this._fetchTimeout(url, options, {
      method: 'POST',
      body: body
    }).then(resOrError);
  };

  _proto.postFeedChunk = function postFeedChunk(meta, data, options, signParams) {
    var _this6 = this;

    var body = (0, _hex.default)(data).toBuffer();
    var digest = (0, _feed.createFeedDigest)(meta, body);
    return this.sign(digest, signParams).then(function (signature) {
      var params = {
        user: meta.feed.user,
        topic: meta.feed.topic,
        time: meta.epoch.time,
        level: meta.epoch.level,
        signature: signature
      };
      return _this6.postSignedFeedChunk(params, body, options);
    });
  };

  _proto.setFeedChunk = function setFeedChunk(hashOrParams, data, options, signParams) {
    var _this7 = this;

    return this.getFeedMetadata(hashOrParams, options).then(function (meta) {
      return _this7.postFeedChunk(meta, data, options, signParams);
    });
  };

  _proto.setFeedContentHash = function setFeedContentHash(hashOrParams, contentHash, options, signParams) {
    var _this8 = this;

    return this.getFeedMetadata(hashOrParams, options).then(function (meta) {
      return _this8.postFeedChunk(meta, "0x" + contentHash, options, signParams);
    });
  };

  _proto.setFeedContent = function setFeedContent(hashOrParams, data, options, signParams) {
    var _this9 = this;

    if (options === void 0) {
      options = {};
    }

    var _options2 = options,
        _c = _options2.contentType,
        feedOptions = (0, _objectWithoutPropertiesLoose2.default)(_options2, ["contentType"]);
    return Promise.all([this.upload(data, options), this.getFeedMetadata(hashOrParams, feedOptions)]).then(function (_ref) {
      var hash = _ref[0],
          meta = _ref[1];
      return _this9.postFeedChunk(meta, "0x" + hash, feedOptions, signParams).then(function () {
        return hash;
      });
    });
  };

  return BaseBzz;
}();

exports.default = BaseBzz;