import _construct from "@babel/runtime/helpers/esm/construct";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { Observable, Subscriber } from 'rxjs';
import BaseRPC from '@mainframe/rpc-base';
import RPCError from '@mainframe/rpc-error';

var StreamRPC =
/*#__PURE__*/
function (_BaseRPC) {
  _inheritsLoose(StreamRPC, _BaseRPC);

  function StreamRPC(transport) {
    var _this;

    _this = _BaseRPC.call(this, true) || this;

    _defineProperty(_assertThisInitialized(_this), "_observers", void 0);

    _defineProperty(_assertThisInitialized(_this), "_subscribers", void 0);

    _defineProperty(_assertThisInitialized(_this), "_subscription", void 0);

    _defineProperty(_assertThisInitialized(_this), "_transport", void 0);

    _this._observers = new Map();
    _this._subscribers = new Set();
    _this._transport = transport;

    _this.connect();

    return _this;
  }

  var _proto = StreamRPC.prototype;

  _proto.connect = function connect() {
    var _this2 = this;

    if (this.connected) {
      return;
    }

    var failed;
    this._subscription = this._transport.subscribe({
      next: function next(msg) {
        if (msg.id == null) {
          _this2._subscribers.forEach(function (o) {
            o.next(msg);
          });
        } else {
          var observer = _this2._observers.get(String(msg.id));

          if (observer != null) {
            if (msg.error != null) {
              var err = RPCError.fromObject(msg.error);
              observer.error(err);

              if (msg.id != null) {
                _this2._observers.delete(String(msg.id));
              }
            } else {
              observer.next(msg.result);
            }
          } else {
            // eslint-disable-next-line no-console
            console.warn('Missing observer for message ID:', msg.id);
          }
        }
      },
      error: function error(event) {
        var err;

        if (event instanceof Error) {
          err = event;
        } else {
          err = new Error('Connection failed');
        }

        failed = err;

        _this2._observers.forEach(function (o) {
          o.error(err);
        });

        _this2._observers.clear();

        _this2._subscribers.forEach(function (o) {
          o.error(err);
        });

        _this2._subscribers.clear();
      },
      complete: function complete() {
        _this2._observers.forEach(function (o) {
          o.complete();
        });

        _this2._observers.clear();

        _this2._subscribers.forEach(function (o) {
          o.complete();
        });

        _this2._subscribers.clear();
      }
    });

    if (failed != null) {
      throw failed;
    }
  };

  _proto.disconnect = function disconnect() {
    this._transport.complete();
  };

  _proto.observe = function observe(method, params) {
    var _this3 = this;

    return Observable.create(function (observer) {
      var id = _this3.createId();

      var msg = {
        jsonrpc: '2.0',
        method: method,
        id: id,
        params: params
      };

      _this3._observers.set(id, new Subscriber(observer));

      _this3._transport.next(msg);

      return function () {
        _this3._observers.delete(id);
      };
    });
  };

  _proto.request = function request(method, params) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      if (_this4.connected) {
        var sub = _this4.observe(method, params).subscribe(function (value) {
          sub.unsubscribe();
          resolve(value);
        }, function (err) {
          sub.unsubscribe();
          reject(err);
        }, function () {
          sub.unsubscribe();
        });
      } else {
        reject(new Error('Not connected'));
      }
    });
  };

  _proto.notify = function notify(method, params) {
    this._transport.next({
      jsonrpc: '2.0',
      method: method,
      params: params
    });
  };

  _proto.subscribe = function subscribe() {
    var _this5 = this;

    if (!this.connected) {
      throw new Error('Not connected');
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var subscriber = _construct(Subscriber, args);

    this._subscribers.add(subscriber);

    return function () {
      _this5._subscribers.delete(subscriber);
    };
  };

  _createClass(StreamRPC, [{
    key: "connected",
    get: function get() {
      return this._subscription != null && !this._subscription.closed;
    }
  }]);

  return StreamRPC;
}(BaseRPC);

export { StreamRPC as default };