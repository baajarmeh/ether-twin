import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import createHex, { hexValueType } from '@erebos/hex';
import { Observable } from 'rxjs';
var EMPTY_HEX = hexValueType('0x');

var Pss =
/*#__PURE__*/
function () {
  function Pss(rpc) {
    _defineProperty(this, "_rpc", void 0);

    if (!rpc.canSubscribe) {
      throw new Error('Invalid RPC instance provided: must support subscriptions');
    }

    this._rpc = rpc;
  }

  var _proto = Pss.prototype;

  _proto.baseAddr = function baseAddr() {
    return this._rpc.request('pss_baseAddr').then(hexValueType);
  };

  _proto.getPublicKey = function getPublicKey() {
    return this._rpc.request('pss_getPublicKey').then(hexValueType);
  };

  _proto.sendAsym = function sendAsym(key, topic, message) {
    return this._rpc.request('pss_sendAsym', [key, topic, createHex(message).value]);
  };

  _proto.sendSym = function sendSym(keyID, topic, message) {
    return this._rpc.request('pss_sendSym', [keyID, topic, createHex(message).value]);
  };

  _proto.sendRaw = function sendRaw(address, topic, message) {
    if (address === void 0) {
      address = EMPTY_HEX;
    }

    return this._rpc.request('pss_sendRaw', [address, topic, createHex(message).value]);
  };

  _proto.setPeerPublicKey = function setPeerPublicKey(key, topic, address) {
    if (address === void 0) {
      address = EMPTY_HEX;
    }

    return this._rpc.request('pss_setPeerPublicKey', [key, topic, address]);
  };

  _proto.setSymmetricKey = function setSymmetricKey(key, topic, address, useForDecryption) {
    if (address === void 0) {
      address = EMPTY_HEX;
    }

    if (useForDecryption === void 0) {
      useForDecryption = false;
    }

    return this._rpc.request('pss_setSymmetricKey', [key, topic, address, useForDecryption]);
  };

  _proto.stringToTopic = function stringToTopic(str) {
    return this._rpc.request('pss_stringToTopic', [str]).then(hexValueType);
  };

  _proto.subscribeTopic = function subscribeTopic(topic, handleRawMessages) {
    if (handleRawMessages === void 0) {
      handleRawMessages = false;
    }

    return this._rpc.request('pss_subscribe', ['receive', topic, handleRawMessages, false]).then(hexValueType);
  };

  _proto.createSubscription = function createSubscription(subscription) {
    var _this = this;

    return Observable.create(function (observer) {
      return _this._rpc.subscribe({
        next: function next(msg) {
          if (msg.method === 'pss_subscription' && msg.params != null && msg.params.subscription === subscription) {
            var result = msg.params.result;

            if (result != null) {
              try {
                observer.next({
                  key: result.Key && result.Key.length ? result.Key : undefined,
                  msg: createHex(result.Msg)
                });
              } catch (err) {
                // eslint-disable-next-line no-console
                console.warn('Error handling message', result, err);
              }
            }
          }
        },
        error: function error(err) {
          observer.error(err);
        },
        complete: function complete() {
          observer.complete();
        }
      });
    });
  };

  _proto.createTopicSubscription = function createTopicSubscription(topic, handleRawMessages) {
    var _this2 = this;

    return this.subscribeTopic(topic, handleRawMessages).then(function (subscription) {
      return _this2.createSubscription(subscription);
    });
  };

  return Pss;
}();

export { Pss as default };