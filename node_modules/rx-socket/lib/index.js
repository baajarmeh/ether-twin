"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SocketSubject = void 0;

var _net = require("net");

var _oboe = _interopRequireDefault(require("oboe"));

var _rxjs = require("rxjs");

var _Subject = require("rxjs/internal/Subject");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SocketSubject extends _Subject.AnonymousSubject {
  constructor(pathOrConfig) {
    super();
    this._config = typeof pathOrConfig === 'string' ? {
      path: pathOrConfig
    } : pathOrConfig;
    this._socket = null;
    this._output = new _rxjs.Subject();
    this.destination = new _rxjs.ReplaySubject();
  }

  _subscribe(subscriber) {
    if (this._socket === null) {
      this._connectSocket();
    }

    const subscription = new _rxjs.Subscription();
    subscription.add(this._output.subscribe(subscriber));
    subscription.add(() => {
      if (this._output.observers.length === 0) {
        if (this._socket !== null) {
          this._socket.end();
        }

        this._reset();
      }
    });
    return subscription;
  }

  unsubscribe() {
    if (this._socket !== null) {
      this._socket.end();

      this._reset();
    }

    super.unsubscribe();
  }

  _connectSocket() {
    const {
      path,
      openObserver,
      closeObserver
    } = this._config;
    const observer = this._output;
    const socket = (0, _net.createConnection)(path);
    this._socket = socket;
    const subscription = new _rxjs.Subscription();
    socket.on('connect', () => {
      if (openObserver != null) {
        openObserver.next();
      }

      const queue = this.destination;
      this.destination = _rxjs.Subscriber.create(msg => {
        if (msg != null) {
          socket.write(JSON.stringify(msg));
        }
      }, err => {
        observer.error(err);

        this._reset();
      }, () => {
        socket.end();

        this._reset();
      });

      if (queue !== undefined && queue instanceof _rxjs.ReplaySubject) {
        subscription.add(queue.subscribe(this.destination));
      }
    });
    socket.on('close', hadError => {
      this._reset();

      if (closeObserver != null) {
        closeObserver.next(hadError);
      }

      if (hadError) {
        observer.error(new Error('Connection closed'));
      } else {
        observer.complete();
      }
    });
    (0, _oboe.default)(socket).on('done', value => {
      try {
        observer.next(value);
      } catch (err) {
        observer.error(err);
      }
    }).on('fail', report => {
      if (report.thrown !== undefined) {
        observer.error(report.thrown);
      } else {
        observer.error(new Error(report.body === undefined ? 'Socket error' : report.body));
      }
    });
  }

  _reset() {
    this._socket = null;
    this._output = new _rxjs.Subject();
  }

}

exports.SocketSubject = SocketSubject;